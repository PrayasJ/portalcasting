#' @title Forecast covariates for forecasting or hindcasting
#' 
#' @description 
#'   \code{forecast_covariates}: overall forecast covariates function \cr \cr
#'   \code{forecast_ndvi}: forecasts specific NDVI values \cr \cr
#'   \code{forecast_weather}: forecasts specific weather values \cr \cr
#'   \code{get_climate_forecasts}: downloads downscaled weather forecasts for 
#'   Portal
#'   
#' @details
#'   \code{forecast_covariates}: forecasts covariates (NDVI and 
#'   weather) based on the forecast type (\code{"forecast"} or 
#'   \code{"hindcast"}) as indicated by \code{control$cast_type}. \cr \cr
#'   \code{forecast_ndvi}: wraps around 
#'   \code{\link[portalr]{fcast_ndvi}} to forecast specific NDVI values
#'   as requested by a portalcasting directory based on existing NDVI values
#'   (from \code{covariates}) and \code{moons} data, and controlled by
#'   \code{control} (see \code{\link{covariates_control}}). \cr \cr
#'   \code{forecast_weather}: Wraps around 
#'   \code{\link{get_climate_forecasts}} to forecast weather covariates 
#'   (min, max, and mean of temperatures and total precipitation for each
#'   newmoon) as requested by a portalcasting directory and controlled through
#'   \code{control} (see \code{\link{covariates_control}}). \cr \cr
#'   \code{get_climate_forecasts}: lunar cycle-based climate forecasts 
#'   obtained from \href{https://bit.ly/2tCP8NX}{Northwest Knowledge
#'   Network (NKN) at the University of Idaho}
#'   and downscaled to Portal, AZ (31.9555, -109.0744). The downscaled 
#'   forecasts are based on the 
#'   \href{http://www.cpc.ncep.noaa.gov/products/NMME/}{North American 
#'   Multi-Model Ensemble}, and specifically the ENSMEAN (ensemble mean) 
#'   model. \cr \cr
#'
#' @param covariates Class-\code{covariates} \code{data.frame} of 
#'   historical covariate data generated by 
#'   \code{\link{prep_hist_covariates}}.
#'
#' @param moons Class-\code{moons} \code{data.frame} containing the historic 
#'   and future newmoons, as produced by \code{\link{prep_moons}}. For input 
#'   into \code{forecast_weather} and \code{forecast_ndvi}, \code{moons} 
#'   should be trimmed by \code{\link{trim_moons_fcast}}.
#'
#' @param tree \code{dirtree}-class directory tree list. See 
#'   \code{\link{dirtree}}.
#'
#' @param quiet \code{logical} indicator if progress messages should be
#'   quieted.
#'
#' @param control \code{list} of options for the covariate data. 
#'   See \code{\link{covariates_control}}.
#'
#' @return 
#'   \code{forecast_covariates}: \code{data.frame} with needed 
#'   forecasted covariates. \cr \cr
#'   \code{forecast_ndvi}: \code{data.frame} of needed forecasted NDVI values.
#'   \cr \cr
#'   \code{forecast_weather}: \code{data.frame} of needed forecasted
#'   temperature and precipitation values. \cr \cr
#'   \code{get_climate_forecasts}: Class-\code{climate_forecast} 
#'   \code{data.frame} with columns 
#'   of \code{newmoonnumber}, \code{mintemp}, \code{maxtemp}, \code{meantemp},
#'   and \code{precipitation}. Temperatures are in C, precipitation is in mm.
#'
#' @export
#'
forecast_covariates <- function(covariates, moons, tree = dirtree(),
                                quiet = FALSE, control = list()){
  control <- do.call("covariates_control", control)
  control <- enforce_covariates_control(control, covariates, moons)
  if (control$cast_type == "forecasts"){
    moons <- trim_moons_fcast(moons, control)
    weather_f <- forecast_weather(moons, tree, quiet, control)
    ndvi_f <- forecast_ndvi(covariates, moons, control)
    fcast <- right_join(weather_f, ndvi_f, by = "newmoonnumber")
    forecast_newmoon <- max(moons$newmoonnumber)
    out <- round(data.frame(forecast_newmoon, fcast), 3)
  }
  if (control$cast_type == "hindcasts"){
    end_step <- control$end[control$hind_step]
    pth <- file_paths(tree, "data/covariate_forecasts.csv")
    hist_fcast <- read.csv(pth, stringsAsFactors = FALSE)
    nmin <- hist_fcast$newmoonnumber %in% control$fcast_nms
    esin <- hist_fcast$forecast_newmoon %in% end_step
    out <- select(hist_fcast[which(nmin & esin), ], -date_made)
  }
  classy(out, c(control$class, "data.frame"))
}

#' @rdname forecast_covariates
#' 
#' @export
#'
forecast_ndvi <- function(covariates, moons, control){
  control <- do.call("covariates_control", control)
  ndvi_data <- select(covariates, c("newmoonnumber", "ndvi"))
  ndvi_lead <- control$nfcnm - control$min_lag
  fcast_ndvi(ndvi_data, "newmoon", lead = ndvi_lead, moons)
}

#' @rdname forecast_covariates
#'
#' @export
#'
forecast_weather <- function(moons = prep_moons(), tree = dirtree(),
                             quiet = FALSE, control = list()){
  control <- do.call("covariates_control", control)
  mpath <- main_path(tree)
  dayweather <- weather("daily", fill = TRUE, mpath)
  yrs <- dayweather$year
  mns <- dayweather$month
  dys <- dayweather$day
  dayweather$date <- as.Date(paste(yrs, mns, dys, sep = "-"))

  newmoon_number <- moons$newmoonnumber[-1]
  newmoon_start <- as.Date(moons$newmoondate[-nrow(moons)])
  newmoon_end <- as.Date(moons$newmoondate[-1])
  newmoon_match_number <- NULL
  newmoon_match_date <- NULL

  for (i in seq(newmoon_number)) {
    temp_dates <- seq.Date(newmoon_start[i] + 1, newmoon_end[i], 1)
    temp_dates <- as.character(temp_dates)
    temp_numbers <- rep(newmoon_number[i], length(temp_dates))
    newmoon_match_date <- c(newmoon_match_date, temp_dates)
    newmoon_match_number <- c(newmoon_match_number, temp_numbers)
  }
  newmoon_match_date <- as.Date(newmoon_match_date)
  matches <- match(dayweather$date, newmoon_match_date)
  dayweather$newmoonnumber <- newmoon_match_number[matches]
  newweather <- dayweather %>% 
                group_by(newmoonnumber) %>% 
                summarize(date = max(date, na.rm = TRUE), 
                          mintemp = min(mintemp, na.rm = TRUE), 
                          maxtemp = max(maxtemp, na.rm = TRUE), 
                          meantemp = mean(meantemp, na.rm = TRUE), 
                          precipitation = sum(precipitation, na.rm = TRUE), 
                          locally_measured = all(locally_measured), 
                          battery_low = all(battery_low, na.rm = TRUE)) %>% 
               arrange(newmoonnumber) %>% 
               select(newmoonnumber, date, mintemp, maxtemp, meantemp, 
                      precipitation, locally_measured, battery_low) %>% 
               mutate(battery_low = ifelse(date < "2003-01-01", 
                   NA, battery_low)) %>% 
               select(-c(.data$locally_measured, .data$battery_low)) %>% 
               mutate(year = as.numeric(format(date, "%Y"))) %>% 
               filter(year >= control$start - 5)
    incompletes <- which(is.na(newweather$newmoonnumber))
    if (length(incompletes) > 0) {
        newweather <- newweather[-incompletes, ]
    }
    fcasts <- get_climate_forecasts(moons, tree, quiet, control)
    tail(newweather, control$min_lag) %>% 
    select(-year, -date) %>% 
    bind_rows(fcasts)
}


#' @title Trim the moons table for covariate forecasting
#' 
#' @description Covariate forecasting requires a moons data table that is
#'   trimmed to the moons of interest only. 
#'
#' @param moons Class-\code{moons} type of a \code{data.frame} containing the
#'   moons and date data. See \code{\link{prep_moons}}.
#'
#' @param control \code{list} of options for the covariate data. 
#'   See \code{\link{covariates_control}}.
#'
#' @return A trimmed \code{moons} \code{data.frame}.
#'
#' @export
#'
trim_moons_fcast <- function(moons, control = list()){
  control <- do.call("covariates_control", control)
  moons <- moons[, c("newmoonnumber", "newmoondate", "period", "censusdate")]
  fc_nms <- moons
  addl_fcast <- which(moons$newmoonnumber %in% control$fcast_nms)
  if (length(addl_fcast) > 0){
    fc_nms <- fc_nms[-addl_fcast, ]
  }
  fc_nms
}

#' @rdname forecast_covariates
#'
#' @export
#'
get_climate_forecasts <- function(moons = prep_moons(), tree = dirtree(),
                                  quiet = FALSE, control = list()){
  control <- do.call("covariates_control", control)
  lead_time <- control$lead_time - control$min_lag

  if(!lead_time %in% 1:7){
    stop(paste0("Lead time must be an integer 1 - 7, got: ", lead_time))
  }

  climate_model <- "ENSMEAN"
  lat <- 31.9555
  lon <- -109.0744

  last_moon <- tail(moons, 1)
  last_moon$newmoondate <- as.Date(as.character(last_moon$newmoondate))
  future_moons <- get_future_moons(moons, num_future_moons = lead_time)
  start_time <- as.character(as.Date(last_moon$newmoondate) + 1)
  end_time <- future_moons$newmoondate[lead_time]
  days_for_forecast <- seq.Date(as.Date(start_time), as.Date(end_time), 1)
  daily_forecasts <- data.frame(date = days_for_forecast)
  start_time <- paste0(start_time, "T00%3A00%3A00Z")
  end_time <- paste0(end_time, "T00%3A00%3A00Z")
  
  base_url_1 <- "https://tds-proxy.nkn.uidaho.edu/thredds/ncss/"
  base_url_2 <- "NWCSC_INTEGRATED_SCENARIOS_ALL_CLIMATE/bcsd-nmme/"
  base_url_3 <- "dailyForecasts/bcsd_nmme_metdata_"
  base_url <- paste(base_url_1, base_url_2, base_url_3, sep = "")
  type_urls <- c("tasmin", "tasmean", "tasmax", "pr")
  full_urls <- paste0(base_url, climate_model, "_forecast_", type_urls, 
                      "_daily.nc?var=", type_urls, "&latitude=", lat, 
                      "&longitude=", lon, "&time_start=", start_time, 
                      "&time_end=", end_time, "&accept=csv")

  good_dl <- FALSE
  check <- check_url(full_urls[1], quiet)
  expect_err <- "SSL certificate problem: certificate has expired"
  if (identical(check, expect_err)){
    messageq(paste0("Note: ", check), quiet)
    if(control$override_ssl_cert_exp){
      messageq("Certificate issue overridden", quiet)
    } else{
      empty_df <- data.frame(matrix(NA, 0, 5))
      enames <- c("date", "mintemp", "meantemp", "maxtemp", "precipitation")
      empty_df <- setNames(empty_df, enames)
      return(empty_df)
    }
  } else{
    good_dl <- TRUE
  }

  handle <- new_handle(ssl_verifypeer = good_dl)
  curl1 <- curl(full_urls[1], handle = handle)
  curl2 <- curl(full_urls[2], handle = handle)
  curl3 <- curl(full_urls[3], handle = handle)
  curl4 <- curl(full_urls[4], handle = handle)
  df1 <- suppressMessages(read_csv(curl1))
  df2 <- suppressMessages(read_csv(curl2))
  df3 <- suppressMessages(read_csv(curl3))
  df4 <- suppressMessages(read_csv(curl4))

  colnames(df1) <- c("date", "lat", "lon", "mintemp")
  colnames(df2) <- c("date", "lat", "lon", "meantemp")
  colnames(df3) <- c("date", "lat", "lon", "maxtemp")
  colnames(df4) <- c("date", "lat", "lon", "precipitation")
  df1$mintemp[df1$mintemp == -9999] <- NA
  df2$meantemp[df2$meantemp == -9999] <- NA
  df3$maxtemp[df3$maxtemp == -9999] <- NA
  df4$precipitation[which(df4$precipitation < 0)] <- 0
  df <- df1 %>% 
        right_join(df2, by = c("date", "lat", "lon")) %>% 
        right_join(df3, by = c("date", "lat", "lon")) %>% 
        right_join(df4, by = c("date", "lat", "lon")) %>% 
        mutate(date = as_date(date)) %>% 
        select(-lat, -lon) %>%
        mutate(mintemp = (mintemp - 32) * 5 / 9) %>%
        mutate(maxtemp = (maxtemp - 32) * 5 / 9) %>%
        mutate(meantemp = (meantemp - 32) * 5 / 9) %>%
        mutate(precipitation = precipitation * 25.4)

  daily_fcast <- full_join(daily_forecasts, df, by = "date")

  hist_path <- main_path(tree)
  historic <- weather("daily", fill = TRUE, path = hist_path)
  datechar <- paste(historic$year, historic$month, historic$day, sep = "-")
  historic$date <- as.Date(datechar)

  avail_historic <- which(daily_forecasts$date %in% historic$date)
  n_avail_historic <- length(avail_historic)

  if(n_avail_historic > 0){
    dates_avail <- daily_fcast$date[avail_historic]
    in_hist <- which(historic$date %in% dates_avail)
    in_fcast <- which(daily_fcast$date %in% dates_avail)
    daily_fcast$mintemp[in_fcast] <- historic$mintemp[in_hist]
    daily_fcast$meantemp[in_fcast] <- historic$meantemp[in_hist]
    daily_fcast$maxtemp[in_fcast] <- historic$maxtemp[in_hist]
    daily_fcast$precipitation[in_fcast] <- historic$precipitation[in_hist]
  }

  temp_moons <- rbind(last_moon, future_moons)
  newmoon_number <- temp_moons$newmoonnumber[-1]
  newmoon_start <- temp_moons$newmoondate[-(1 + lead_time)] 
  newmoon_end <- temp_moons$newmoondate[-1]
  newmoon_match_number <- NULL
  newmoon_match_date <- NULL
  for(i in 1:lead_time){
    date_seq <- seq.Date(newmoon_start[i] + 1, newmoon_end[i], 1)
    if (date_seq[length(date_seq)] != newmoon_end[i]){
      date_seq <- c(date_seq, newmoon_end[i])
    }
    temp_dates <- as.character(date_seq)
    temp_numbers <- rep(newmoon_number[i], length(temp_dates))
    newmoon_match_date <- c(newmoon_match_date, temp_dates)
    newmoon_match_number <- c(newmoon_match_number, temp_numbers)   
  }  
  newmoon_match_date <- as.Date(newmoon_match_date)
  which_match <- match(daily_forecasts$date, newmoon_match_date)
  daily_fcast$newmoonnumber <- newmoon_match_number[which_match]

  daily_fcast %>% 
  group_by(newmoonnumber) %>%
  summarize(mintemp = min(mintemp, na.rm = T), 
            maxtemp = max(maxtemp, na.rm = T), 
            meantemp = mean(meantemp, na.rm = T), 
            precipitation = sum(precipitation, na.rm = T)) %>%
  classy(c("climate_forecast", "data.frame", "tbl_df", "tbl"))
}


