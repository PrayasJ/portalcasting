#' @title Prepare temporal (lunar) data
#'
#' @description Get time information (calendar dates, census periods, 
#'   newmoon numbers) associated with trapping events (achieved and missed)
#'   based on a lunar survey schedule. If needed, additional moons will be
#'   added to both the in-use and raw versions of the data table. 
#'
#' @param options_moons A class-\code{moons_options} \code{list} of options 
#'   for the moons data. See \code{\link{moons_options}}.
#'
#' @return Moons data table as a code{moons}-class \code{data.frame}.
#'
#' @export
#' 
prep_moons <- function(options_moons = moons_options()){
  if (!("moons_options") %in% class(options_moons)){
    stop("`options_moons` is not a moons_options list")
  }
  if (!options_moons$quiet){
    message("Loading moons data file into the data subdirectory")
  }
  verify_PortalData(options_moons$tree, "moon_dates.csv")
  file_path(options_moons$tree, "PortalData/Rodents/moon_dates.csv") %>%
  read.csv(stringsAsFactors = FALSE) %>% 
  classy(c("data.frame", "moons")) %>%
  add_future_moons(options_moons) %>%
  append_past_moons_to_raw(options_moons) %>%
  format_moons() %>%
  dataout(options_moons)
}


#' @title Append missing past moons to the raw data
#'
#' @description Sometimes the raw moon data table is not up-to-date. Because
#'   the \code{portalr} functions \code{\link[portalr]{weather}} and 
#'   \code{\link[portalr]{fcast_ndvi}} point to the raw moons data, that table
#'   needs to be updated to produce the correct current data table for 
#'   casting. 
#'
#' @param moons Moons data table as a code{moons}-class \code{data.frame}.
#'
#' @param options_moons A class-\code{moons_options} \code{list} of options 
#'   for the moons data. See \code{\link{moons_options}}.
#'
#' @return \code{moons} as it was input (a \code{moons}-class 
#'   \code{data.frame}).
#'
#' @export
#'
append_past_moons_to_raw <- function(moons, options_moons = moons_options()){
  if (!("moons_options") %in% class(options_moons)){
    stop("`options_moons` is not a moons_options list")
  }
  if (!("moons") %in% class(moons)){
    stop("`moons` is not a moons data table")
  }
  if (options_moons$append_missing_to_raw){
    path <- file_path(options_moons$tree, "PortalData/Rodents/moon_dates.csv")
    included_moons <- moons$newmoondate < today()
    newraw <- moons[included_moons, ]
    write.csv(newraw, path, row.names = FALSE)
  }
  moons
}


#' @title Add future moons to the moon table
#'
#' @description Add future moons to the moon table, counting forward from
#'   the forecast date (\code{options_moons$cast_date}). Because the 
#'   \code{moons} table might not have the most recent moons, more rows than 
#'   anticipated (\code{options_moons$n_future_moons}) may need to be added to 
#'   the table.
#'
#' @param moons Moons data table as a code{moons}-class \code{data.frame}.
#'
#' @param options_moons control options list for moons
#'
#' @return Appended \code{moons} data table as a \code{moons}-class 
#'   \code{data.frame}.
#'
#' @export
#' 
add_future_moons <- function(moons = prep_moons(), 
                             options_moons = moons_options()){
  if (!("moons_options") %in% class(options_moons)){
    stop("`options_moons` is not a moons_options list")
  }
  if (!("moons") %in% class(moons)){
    stop("`moons` is not a moons data table")
  }
  if (options_moons$n_future_moons == 0){
    return(moons)
  }
  get_future_moons(moons, options_moons$n_future_moons) %>% 
  classy(c("data.frame", "moons")) %>% 
  add_addl_future_moons(options_moons$cast_date) %>%
  mutate(newmoondate = as.character(newmoondate)) %>%
  bind_rows(moons, .)

}

#' @title Add more more moons to accomplish requested forecast length
#'
#' @description Add extra future moons to the moon table to achieve requested
#'   forecast length. Because the moon table might not have the most recent 
#'   moons, more rows than initially requested may need to be added to the 
#'   table for it to be of the required coverage.
#'
#' @param future_moons A \code{moons}-class \code{data.frame} forward from 
#'   the historic moons table (produced by \code{\link{prep_moons}}), as
#'   generated by \code{\link[portalr]{get_future_moons}}.  
#'
#' @param cast_date \code{Date} from which future is defined, typically 
#'   today's date (using \code{\link{today}}).
#'
#' @return appended moon table
#'
#' @export
#' 
add_addl_future_moons <- function(future_moons, cast_date){
  if (!("moons") %in% class(future_moons)){
    stop("`future_moons` is not a moons data table")
  }
  if (!("Date" %in% class(cast_date))){
    stop("`cast_date` is not of class Date")
  }
  if (length(cast_date) > 1){
    stop("`cast_date` can only be of length = 1")
  }
  n_addl_future_moons <- length(which(future_moons$newmoondate < cast_date))
  if (n_addl_future_moons > 0){
    addl_moons <- get_future_moons(future_moons, n_addl_future_moons)
    future_moons <- bind_rows(future_moons, addl_moons)
  } 
  future_moons
}

#' @title Format the moon data
#'
#' @description Enforce the \code{year} and \code{month} columns and encode 
#'   \code{newmoondate} as a \code{\link{Date}}.
#'
#' @param moons Moons data table as a code{moons}-class \code{data.frame}.
#'
#' @return Moons data table as a code{moons}-class \code{data.frame} with
#'   force-formatted columns. 
#'
#' @export
#' 
format_moons <- function(moons){
  if (!("moons") %in% class(moons)){
    stop("`moons` is not a moons data table")
  }
  moons$year <- year(moons$newmoondate)
  moons$month <- month(moons$newmoondate)
  moons$newmoondate <- as.Date(moons$newmoondate)
  moons
}
