#' @title Prepare a list of rodents data tables for forecasting
#'
#' @description This function wraps around \code{\link{prep_rodents_table}} to 
#'  produce a list of rodents \code{data.frame}s associated with multiple
#'  sets of specifications. The default settings are for a general 
#'  portalcasting directory, which models the "all" and "controls" data 
#'  subsets.
#'
#' @param controls_r Control \code{list} or \code{list} of control 
#'  \code{list}s from \code{\link{rodents_controls}} specifying the 
#'  structuring of the rodents tables. See \code{\link{rodents_controls}} for 
#'  details. 
#'
#' @param main \code{character} value of the name of the main component of
#'  the directory tree. 
#'
#' @param quiet \code{logical} indicator if progress messages should be
#'  quieted.
#'
#' @param moons Moons \code{data.frame}. See \code{\link{prep_moons}}.
#
#' @param tmnt_types \code{character} values of the treatment 
#'  types (currently \code{"all"} or \code{"controls"}) used to enforce 
#'  certain arguments in data creation (see \code{\link{prep_rodents_table}}).
#'
#' @param ref_species \code{character}-valued vector of all possible species 
#'  names that could be used should be set up via \code{\link{all_species}}.
#'
#' @param save \code{logical} indicator controlling if the output should 
#'   be saved out.
#'
#' @param overwrite \code{logical} indicator of whether or not the existing
#'  files should be updated (most users should leave as \code{TRUE}).
#'
#' @param start_moon \code{integer} (or integer \code{numeric}) newmoon number 
#'  of the first sample to be included. Default value is \code{217}, 
#'  corresponding to \code{1995-01-01}.
#'
#' @param end_moon \code{integer} (or integer \code{numeric}) newmoon number 
#'  of the last sample to be included. Default value is \code{NULL}, which 
#'  equates to the most recently included sample. 
#'
#' @param arg_checks \code{logical} value of if the arguments should be
#'  checked using standard protocols via \code{\link{check_args}}. The 
#'  default (\code{arg_checks = TRUE}) ensures that all inputs are 
#'  formatted correctly and provides directed error messages if not. \cr
#'  However, in sandboxing, it is often desirable to be able to deviate from 
#'  strict argument expectations. Setting \code{arg_checks = FALSE} triggers
#'  many/most/all enclosed functions to not check any arguments using 
#'  \code{\link{check_args}}, and as such, \emph{caveat emptor}.
#'
#' @return \code{list} of \code{data.frame}s, one for each data subset
#'  specified, as generated by \code{\link{prep_rodents_table}}.
#'
#' @examples
#'  \donttest{
#'    create_dir()
#'    fill_raw()
#'    prep_rodents()
#'  }
#'
#' @export
#'
prep_rodents <- function(main = ".", moons = NULL, 
                         tmnt_types = c("all", "controls"),
                         end_moon = NULL, start_moon = 217,
                         controls_r = NULL,
                         ref_species = all_species(), quiet = FALSE,
                         save = TRUE, overwrite = TRUE, arg_checks = TRUE){
  moons <- ifnull(moons, read_moons(main = main))
  check_args(arg_checks)
  controls_r <- rodents_controls(tmnt_types, controls_r)

  messageq("Loading rodents data files into data subdirectory", quiet)
  ntmnt <- length(tmnt_types)
  out <- vector("list", length = ntmnt)
  for(i in 1:ntmnt){
    tmnt_args_i <- controls_r[[tmnt_types[i]]]
    needed <- names(formals(prep_rodents_table))
    which_needed <- which(names(tmnt_args_i) %in% needed)
    tmnt_args_i <- tmnt_args_i[which_needed]
    tmnt_args_i[["main"]] <- main
    tmnt_args_i[["quiet"]] <- quiet
    tmnt_args_i[["overwrite"]] <- overwrite
    tmnt_args_i[["save"]] <- save
    tmnt_args_i[["moons"]] <- moons
    tmnt_args_i[["arg_checks"]] <- arg_checks
    tmnt_args_i[["ref_species"]] <- ref_species
    out[[i]] <- do.call(prep_rodents_table, tmnt_args_i)
    names(out)[i] <- controls_r[[i]]$tmnt_type
  }
  out
}


#' @title Prepare a rodents data table for forecasting
#'
#' @description This set of functions provides a convenient wrapper on
#'  \code{\link[portalr]{summarize_rodent_data}} to generate a specific
#'  data table for use in the forecasting pipeline. Many arguments pipe
#'  directly to \code{\link[portalr]{summarize_rodent_data}}. \cr \cr
#'  \code{prep_rodents_table} generates the ready-to-model table. \cr \cr
#'  \code{add_total} adds a total (sum-across-species) column. \cr \cr
#'  \code{trim_treatment} removes not-requested plots according to treatment
#'  levels and then removes the treatment column. \cr \cr
#'  \code{add_moons} adds the lunar data associated with the samples. \cr \cr
#'  \code{trim_time} reduces the table to the samples within the time window
#'  and then removes extra time columns. \cr \cr
#'
#' @param main \code{character} value of the name of the main component of
#'  the directory tree. 
#'
#' @param quiet \code{logical} indicator if progress messages should be
#'  quieted.
#'
#' @param moons Moons \code{data.frame}. See \code{\link{prep_moons}}.
#'
#' @param start_moon \code{integer} (or integer \code{numeric}) newmoon number 
#'  of the first sample to be included. Default value is \code{217}, 
#'  corresponding to \code{1995-01-01}.
#'
#' @param end_moon \code{integer} (or integer \code{numeric}) newmoon number 
#'  of the last sample to be included. Default value is \code{NULL}, which 
#'  equates to the most recently included sample. 
#'
#' @param species \code{character}-valued vector of species names to include 
#'  in the forecasting data table. Defaults to all species but \code{"PI"}
#'  via \code{\link{base_species}}
#'
#' @param ref_species \code{character}-valued vector of all possible species 
#'  names that could be used should be set up via \code{\link{all_species}}.
#'
#' @param total \code{logical} value indicating if a total (sum across 
#'  species) should be added or not. Only available if more than one species
#'  is included. 
#'
#' @param level \code{character} indicating the type of summary:
#'  \code{"Plot"}, \code{"Treatment"}, or \code{"Site"}. Pipes 
#'  directly to \code{\link[portalr]{summarize_rodent_data}}.
#'
#' @param treatment \code{character} indicating the specific treatment(s) to
#'  trim to if \code{level = "Treatment"}: \code{"control"},
#'  \code{"exclosure"}, \code{"removal"}, or \code{"spectabs"} .
#'
#' @param output \code{character} indicating the type of data:
#'  \code{"abundance"}, \code{"biomass"}, or \code{"energy"}. Pipes 
#'  directly to \code{\link[portalr]{summarize_rodent_data}}.
#'
#' @param min_traps \code{integer} (or integer \code{numeric}) of the minimum 
#'  number of traps collected for a plot to be used. Pipes directly to 
#'  \code{\link[portalr]{summarize_rodent_data}}.
#'
#' @param min_plots \code{integer} (or integer \code{numeric}) of the minimum 
#'  number of plots surveyed for a survey to be used.Pipes directly to 
#'  \code{\link[portalr]{summarize_rodent_data}}.
#'
#' @param plots Specification of subset of plots. Can be a vector of 
#'  \code{numeric} plots indicators or specific sets indicated by
#'  \code{character} values: \code{"all"} plots or \code{"Longterm"} plots
#'  (plots that have had the same treatment for the entire time series).
#'
#' @param rodents_tab \code{data.frame} rodents table, with varying levels of 
#'  editing.
#'
#' @param save \code{logical} indicator controlling if the output should 
#'   be saved out.
#'
#' @param filename \code{character} name of the file for saving the output.
#'
#' @param overwrite \code{logical} indicator of whether or not the existing
#'  files should be updated (most users should leave as \code{TRUE}).
#'
#' @param arg_checks \code{logical} value of if the arguments should be
#'  checked using standard protocols via \code{\link{check_args}}. The 
#'  default (\code{arg_checks = TRUE}) ensures that all inputs are 
#'  formatted correctly and provides directed error messages if not. \cr
#'  However, in sandboxing, it is often desirable to be able to deviate from 
#'  strict argument expectations. Setting \code{arg_checks = FALSE} triggers
#'  many/most/all enclosed functions to not check any arguments using 
#'  \code{\link{check_args}}, and as such, \emph{caveat emptor}.
#'
#' @return \code{data.frame} rodents table, with varying levels of editing
#'  for use in forecasting. \cr \cr
#'  \code{prep_rodents_table}, \code{trim_time}: a fully appended and 
#'  formatted \code{data.frame} (also saved out if \code{save = TRUE}). 
#'  \cr \cr
#'  \code{trim_species}, \code{add_total}, \code{trim_treatment}, 
#'  \code{add_moons}: appropriately appended rodents \code{data.frame}.
#'
#' @examples
#'  \donttest{
#'   create_dir()
#'   fill_raw()
#'   prep_rodents_table()
#'   raw_path <- sub_paths(specific_subs = "raw")
#'   dat1 <- portalr::summarize_rodent_data(path = raw_path, clean = FALSE)
#'   dat2 <- trim_species(dat1)
#'   dat3 <- add_total(dat2)
#'   dat4 <- trim_treatment(dat3)
#'   dat5 <- add_moons(dat4)
#'   dat6 <- trim_time(dat5, start_moon = 217, end_moon = 500)
#'  }
#'
#' @export
#'
prep_rodents_table <- function(main = ".", moons = NULL,
                               end_moon = NULL, start_moon = 217, 
                               species = base_species(), total = TRUE, 
                               level = "Site", treatment = NULL,
                               plots = "all", min_plots = 24, min_traps = 1, 
                               output = "abundance",
                               ref_species = all_species(), quiet = TRUE, 
                               save = TRUE, overwrite = TRUE, 
                               filename = "rodents_all.csv", 
                               arg_checks = TRUE){
  moons <- ifnull(moons, read_moons(main = main))
  return_if_null(species) 
  check_args(arg_checks)
  nspecies <- length(species)
  total <- ifelse(nspecies == 1, FALSE, total)
  raw_path <- sub_paths(main, "raw")
  summarize_rodent_data(path = raw_path, clean = FALSE, type = "Rodents", 
                        level = level, plots = plots, min_traps = min_traps,
                        min_plots = min_plots, output = output,
                        quiet = quiet) %>%
  trim_species(species, ref_species) %>%
  add_total(total)  %>%
  trim_treatment(level, treatment) %>%
  add_moons(moons, main) %>%
  trim_time(start_moon, end_moon) %>%
  data_out(main, save, filename, overwrite, quiet)
}

#' @rdname prep_rodents_table
#'
#' @export
#'
trim_time <- function(rodents_tab, start_moon = NULL, end_moon = NULL,
                      arg_checks = TRUE){
  return_if_null(c(start_moon, end_moon), rodents_tab)
  check_args(arg_checks)
  start_moon <- ifnull(start_moon, min(rodents_tab$newmoonnumber))
  end_moon <- ifnull(end_moon, max(rodents_tab$newmoonnumber))
  subset(rodents_tab, newmoonnumber >= start_moon) %>%
  subset(newmoonnumber <= min(c(end_moon, max(newmoonnumber)))) %>%
  select(-newmoondate, -censusdate) 
}

#' @rdname prep_rodents_table
#'
#' @export
#'
add_moons <- function(rodents_tab, moons = NULL, main = ".",
                      arg_checks = TRUE){
  moons <- ifnull(moons, read_moons(main = main))
  check_args(arg_checks)
  inner_join(rodents_tab, moons, by = c("period" = "period"))
}

#' @rdname prep_rodents_table
#'
#' @export
#'
add_total <- function(rodents_tab, total = TRUE, arg_checks = TRUE){
  check_args(arg_checks)
  if(total){
    total_count <- rowSums(rodents_tab[ , is_sp_col(rodents_tab)])
    rodents_tab <- mutate(rodents_tab, total = total_count)
  }
  rodents_tab
}

#' @rdname prep_rodents_table
#'
#' @export
#'
trim_species <- function(rodents_tab, species = base_species(), 
                         ref_species = all_species(), arg_checks = TRUE){
  check_args(arg_checks)
  drop_species <- ref_species[which(ref_species %in% species == FALSE)]
  if(length(drop_species) > 0){
    rodents_tab <- select(rodents_tab, -one_of(drop_species))
  }
  rodents_tab
}

#' @rdname prep_rodents_table
#'
#' @export
#'
trim_treatment <- function(rodents_tab, level = "Site", treatment = NULL, 
                           arg_checks = TRUE){
  check_args(arg_checks)
  if(level == "Treatment"){
    rodents_tab <- filter(rodents_tab, treatment == !!treatment)  %>%
                   select(-treatment)
  }
  rodents_tab
}

#' @title Determine if columns in a table are species columns
#'
#' @description Given a table, returns a \code{logical} vector indicating
#'  if each column is a species' column or not.
#'
#' @param rodents_tab \code{data.frame} of columns to be checked. 
#'
#' @param species \code{character} vector indicating species names to 
#'  use in determining if columns are species columns. Defaults to
#'  \code{\link{all_species}}.
#'
#' @param arg_checks \code{logical} value of if the arguments should be
#'  checked using standard protocols via \code{\link{check_args}}. The 
#'  default (\code{arg_checks = TRUE}) ensures that all inputs are 
#'  formatted correctly and provides directed error messages if not. \cr
#'  However, in sandboxing, it is often desirable to be able to deviate from 
#'  strict argument expectations. Setting \code{arg_checks = FALSE} triggers
#'  many/most/all enclosed functions to not check any arguments using 
#'  \code{\link{check_args}}, and as such, \emph{caveat emptor}.

#'
#' @return \code{logical} vector indicating if each column is a species' 
#'  column or not.
#'
#' @examples
#'  \donttest{
#'   create_dir()
#'   fill_raw()
#'   rodents_tab <- prep_rodents_table()
#'   is_sp_col(rodents_tab)
#'  }
#'
#' @export
#'
is_sp_col <- function(rodents_tab, species = all_species(),
                      arg_checks = TRUE){
  check_args(arg_checks)
  colnames(rodents_tab) %in% species
}

#' @title Rodent species abbreviations
#'
#' @description Creates a simple \code{character} vector of abbreviations for
#'   the \href{https://portal.naturecast.org/profiles.html}{Portal Rodents}.
#'
#' @param set \code{character} input of a specified set of species. 
#'   Default entry (\code{"base"}) returns the standard set of all species 
#'   included. Other options include \code{"wtotal"} (same as \code{"base"} 
#'   but with "total" as well) and \code{"evalplot"} which only returns a 
#'   subset of common species to be included in the evaluations plots.
#'
#' @param nadot \code{logical} indicator if the dot should be added to the 
#'   \code{"NA"} species name. Defaults to \code{FALSE}.
#'
#' @param species \code{character}-valued vector of species names to include.
#'
#' @param total \code{logical} value indicating if \code{"total"} should be 
#'  added or not.
#'
#' @param arg_checks \code{logical} value of if the arguments should be
#'  checked using standard protocols via \code{\link{check_args}}. The 
#'  default (\code{arg_checks = TRUE}) ensures that all inputs are 
#'  formatted correctly and provides directed error messages if not. \cr
#'  However, in sandboxing, it is often desirable to be able to deviate from 
#'  strict argument expectations. Setting \code{arg_checks = FALSE} triggers
#'  many/most/all enclosed functions to not check any arguments using 
#'  \code{\link{check_args}}, and as such, \emph{caveat emptor}.
#'
#' @return \code{character} vector of species abbreviations.
#' 
#' @examples 
#'  rodent_species()
#'  rodent_species(set = "all")
#'  rodent_species("BA")
#'  rodent_species("BA", set = "all")
#'  all_species()
#'  all_species(nadot = TRUE)
#'  all_species(total = TRUE)
#'  base_species()
#'  evalplot_species()
#'
#' @export
#'
rodent_species <- function(species = NULL, set = NULL, nadot = FALSE, 
                           total = FALSE, arg_checks = TRUE){
  return_if_null(c(species, set))
  check_args(arg_checks)
  out <- NULL
  if(!is.null(set) && set == "all"){
    out <- c("BA", "DM", "DO", "DS", "NA", "OL", "OT", "PB", "PE", "PF", "PH", 
             "PI", "PL", "PM", "PP", "RF", "RM", "RO", "SF", "SH", "SO")
  } else if(!is.null(set) && set == "base"){
    out <- c("BA", "DM", "DO", "DS", "NA", "OL", "OT", "PB", "PE", "PF", "PH", 
             "PL", "PM", "PP", "RF", "RM", "RO", "SF", "SH", "SO")
  } else if(!is.null(set) && set == "evalplot"){
    out <- c("BA", "DM", "DO", "PP", "OT", "NA")
  }
  if(total){
    out <- c(out, "total")
  }
  if(nadot){
    out[which(out == "NA")] <- "NA."
  }
  unique(c(species, out))
}

#' @rdname rodent_species
#'
#' @export
#'
all_species <- function(species = NULL, nadot = FALSE, total = FALSE){
  rodent_species(species, "all", nadot, total)
}


#' @rdname rodent_species
#'
#' @export
#'
base_species <- function(species = NULL, nadot = FALSE, total = FALSE){
  rodent_species(species, "base", nadot, total)
}

#' @rdname rodent_species
#'
#' @export
#'
evalplot_species <- function(species = NULL, nadot = FALSE, total = TRUE){
  rodent_species(species, "evalplot", nadot, total)
}

#' @title Create control lists for generating rodents data tables
#'
#' @description Given the number of arguments into 
#'  \code{\link{prep_rodents_table}}, it helps to have a control \code{list}  
#'  to organize them. This function produce those \code{list}s for
#'  standard datasets ("all" and "controls") or user-defined sets.
#
#' @param tmnt_types \code{character} value(s) of the treatment 
#'  type(s) (currently \code{"all"} or \code{"controls"}) used to enforce 
#'  certain arguments. 
#'
#' @param controls_r Additional controls for datasets not in the standard set. 
#'  \cr 
#'  A \code{list} of a single dataset's controls or a \code{list} of 
#'  \code{list}s, each of which is a single dataset's controls. \cr 
#'  Presently, each dataset's controls should include 10 elements: 
#'  \itemize{
#'   \item \code{tmnt_type}: \code{character} value of the name,
#'   \item \code{species}: \code{character}-valued vector of species names 
#'   to include.  
#'   \item \code{total}: \code{logical} value indicating if a total 
#'   (sum across species) should be added or not. Only available if more than 
#'   one species is included. 
#'   \item \code{level}: \code{character} indicating the type of summary:
#'    \code{"Plot"}, \code{"Treatment"}, or \code{"Site"}. Pipes 
#'    directly to \code{\link[portalr]{summarize_rodent_data}}.
#'   \item \code{treatment}: \code{character} indicating the specific 
#'    treatment(s) to trim to if \code{level = "Treatment"}: \code{"control"},
#'    \code{"exclosure"}, \code{"removal"}, or \code{"spectabs"} 
#'   \item \code{output}: \code{character} indicating the type of data:
#'    \code{"abundance"}, \code{"biomass"}, or \code{"energy"}. Pipes 
#'    directly to \code{\link[portalr]{summarize_rodent_data}}.
#'   \item \code{min_traps}: \code{integer} (or integer \code{numeric}) of the 
#'    minimum number of traps collected for a plot to be used. Pipes directly
#'    to \code{\link[portalr]{summarize_rodent_data}}.
#'   \item \code{min_plots}: \code{integer} (or integer \code{numeric}) of the 
#'    minimum number of plots surveyed for a survey to be used. Pipes 
#'    directly to \code{\link[portalr]{summarize_rodent_data}}.
#'   \item \code{plots}: Specification of subset of plots. Can be a vector of 
#'    \code{numeric} plots indicators or specific sets indicated by
#'    \code{character} values: \code{"all"} plots or \code{"Longterm"} plots
#'    (plots that have had the same treatment for the entire time series).
#'   \item \code{filename}: \code{character} name of the file for saving the 
#'    output.
#'  }
#'  If only a single dataset is added, the name of the set from the element
#'  \code{tmnt_type} will be used to name the model's \code{list} in the 
#'  larger \code{list}. If multiple models are added, each element \code{list} 
#'  must be named according to the dataset and the \code{tmnt_type} element.
#'  \cr 
#'  See \code{Details} and \code{Examples}.  
#'
#' @param arg_checks \code{logical} value of if the arguments should be
#'  checked using standard protocols via \code{\link{check_args}}. The 
#'  default (\code{arg_checks = TRUE}) ensures that all inputs are 
#'  formatted correctly and provides directed error messages if not. \cr
#'  However, in sandboxing, it is often desirable to be able to deviate from 
#'  strict argument expectations. Setting \code{arg_checks = FALSE} triggers
#'  many/most/all enclosed functions to not check any arguments using 
#'  \code{\link{check_args}}, and as such, \emph{caveat emptor}.
#'
#' @return Named \code{list} of length equal to the number of elements in 
#'  \code{tmnt_types} and with elements that are each 
#'  \code{list}s of those \code{tmnt_type}'s data-generating controls, for
#'  input as \code{controls_r} in \code{\link{prep_rodents}}.
#'
#' @examples
#'  rodents_controls(c("all", "controls"))
#'  all_PPonly <- list(tmnt_type = "all_PPonly", species = "PP", 
#'                     total = FALSE, filename = "rodents_all_PPonly.csv", 
#'                     level = "Site", treatment = NULL, plots = "all", 
#'                     min_plots = 24, min_traps = 1, output = "abundance")
#'  rodents_controls("all_PPonly", all_PPonly, arg_checks = FALSE)
#'  rodents_controls(c("all", "all_PPonly"), all_PPonly, arg_checks = FALSE)
#'
#' @export
#'
rodents_controls <- function(tmnt_types = NULL, controls_r = NULL, 
                             arg_checks = TRUE){
  check_args(arg_checks)
  return_if_null(tmnt_types)
  if(list_depth(controls_r) == 1){
    controls_r <- list(controls_r)
    names(controls_r) <- controls_r[[1]]$tmnt_type
  }
  nadd <- length(controls_r)

  standard_controls <- list(
    "all" = list(tmnt_type = "all", species = base_species(), total = TRUE,
                 filename = "rodents_all.csv", level = "Site",
                 treatment = NULL, plots = "all", min_plots = 24,
                 min_traps = 1, output = "abundance"),
    "controls" = list(tmnt_type = "controls", species = base_species(), 
                 total = TRUE, filename = "rodents_controls.csv", 
                 level = "Treatment",
                 treatment = "control", plots = "Longterm", min_plots = 24,
                 min_traps = 1, output = "abundance"))

  nstandard <- length(standard_controls)
  for(i in 1:nstandard){
    controls_r[nadd + i] <- list(standard_controls[[i]])
    names(controls_r)[nadd + i] <- names(standard_controls)[i]
  }

  included_data <- which(names(controls_r) %in% tmnt_types)
  missing_controls <- which((tmnt_types %in% names(controls_r)) == FALSE)
  replicates <- table(names(controls_r))
  if(length(missing_controls) > 0){
    which_missing <- tmnt_types[missing_controls]
    all_missing <- paste(which_missing, collapse = ", ")
    msg <- paste0("missing controls for dataset(s): ", all_missing)
    stop(msg)
  }
  if(any(replicates > 1)){
    which_conflicting <- names(replicates)[which(replicates > 1)]
    all_conflicting <- paste(which_conflicting, collapse = ", ")
    msg <- paste0("conflicting copies of dataset(s): ", all_conflicting)
    stop(msg)
  }
  controls_r[included_data]

}

