#' @title Prepare covariate data table
#'
#' @description Set of functions to prepare a covariate data table used in
#'   forecasting. \cr \cr
#'   \code{prep_covariates}: interface-level function
#'   code{download_hist_covariate_forecasts}: download the historical 
#'   covariate data forecasts to the data folder \cr \cr
#'   \code{prep_hist_covariates}: prepares the historical covariates data
#'   \cr \cr
#'   \code{prep_weather_data}: prepares historical weather data \cr \cr
#'   \code{append_cov_fcast_csv}: appends a covariate forecast to 
#'   existing covariate forecasts
#'
#' @details
#'   \code{prep_covariates} is the overall function that prepares the 
#'   covariate data for forecasting or hindcasting, 
#'   including saving out the data and appending the new forecasts of 
#'   covariates to the existing covariate forecast table. \cr \cr
#'   \code{download_hist_covariate_forecasts}: Download the
#'   historical covariates predictions file into the data subdirectory in the
#'   the portalcasting directory tree from 
#'   \href{https://zenodo.org/record/3333770}{Zenodo} (default), 
#'   \href{https://bit.ly/2Lo2xnQ}{portalPredictions repo}, or an old local
#'   version from the package's data).
#'   \code{prep_hist_covariates}: creates a data table of historical 
#'   weather and NDVI data. \cr \cr
#'   \code{prep_weather_data}: creates a data table of historical weather 
#'   data using \code{\link[portalr]{weather}}. \cr \cr
#'   \code{append_cov_fcast_csv}: Add the newest weather and NDVI forecasts to
#'   the existing forecasts data file, for use in future hindcasting.
#'
#' @param moons Class-\code{moons} \code{data.frame} containing the historic 
#'   and future newmoons, as produced by \code{\link{prep_moons}}.
#'
#' @param tree \code{dirtree}-class directory tree list. See 
#'   \code{\link{dirtree}}.
#'
#' @param quiet \code{logical} indicator controlling if messages are printed.
#'
#' @param control \code{list} of parameters to control the preparation of 
#'   moons. See \code{\link{covariates_control}}.
#'
#' @param new_forecast_covariates Class-\code{covariates} \code{data.frame} of
#'   forecasted covariate data generated by 
#'   \code{\link{forecast_covariates}}.
#'
#' @param hist_cov Historical covariate data table as a code{covariates}-class 
#'   \code{data.frame}, returned from \code{\link{prep_hist_covariates}}.
#'
#' @return \code{prep_covariates}: Covariate data table as a 
#'   code{covariates}-class \code{data.frame}. \cr \cr
#'   \code{prep_hist_covariates}: Historical covariate data table as a 
#'   code{covariates}-class \code{data.frame}. \cr \cr
#'   \code{prep_weather_data}: \code{data.frame} of historical weather data.
#'   \cr \cr
#'   \code{append_cov_fcast_csv}: appended \code{new_forecast_covariates}.
#' 
#' @examples
#' \dontrun{
#' 
#' setup_dir()
#' prep_covariates()
#' }
#'
#' @export
#'
prep_covariates <- function(moons = prep_moons(), tree = dirtree(), 
                            quiet = FALSE, control = list()){
  verify_PortalData(tree, quiet = quiet)
  control <- do.call("covariates_control", control)
  messageq("Loading covariate data files into data subdirectory", quiet)
  hist_cov <- prep_hist_covariates(tree, control)
  if (control$cov_fcast){
    fcast_cov <- prep_fcast_covariates(hist_cov, moons, tree, quiet, control)
  }
  out <- hist_cov[-(1:nrow(hist_cov)), ]
  if (control$cov_hist){
    out <- bind_rows(out, hist_cov)
  }
  if (control$cov_fcast){
    out <- bind_rows(out, fcast_cov)
  }
  dataout(out, tree, control)
}

#' @rdname prep_covariates
#'
#' @export
#'
download_hist_covariate_forecasts <- function(tree = dirtree(), quiet = FALSE,
                                              control = list()){
  temp <- NULL
  control <- do.call("covariates_control", control)
  path_to <- file_paths(tree, "data/covariate_forecasts.csv")

  if(!control$download){
    fname <- "extdata/covariate_forecasts.csv"
    path_from <- system.file(fname, package = "portalcasting")
    if (!file.exists(path_from)){
      stop("Historical covariate forecast data not found.")
    }
    temp <- read.csv(path_from, stringsAsFactors = FALSE)
  } else{
    if(control$version != "latest"){
      control$from_zenodo <- FALSE
    }
    releases <- get_releases(control$from_zenodo)
    if (control$version == "latest"){
      match_idx <- 1
    } else{
      grepmatch <- grepl("[0-9]+\\-[0-9]+\\-[0-9]", control$version)
      nchars <- sapply(strsplit(control$version, "-")[[1]], nchar)
      if (!(grepmatch & all(nchars == c(4,2,2)))) {
        stop("Invalid version number; given, ", control$version)
      }
      match_idx <- match(control$version, releases$version)
      if (length(match_idx) != 1 || is.na(match_idx)) {
        stop("Did not find a version of the data matching, ", control$version)
      }
    }
    download_url <- releases$zipball_url[match_idx]
    download_dest <- normalizePath(tempdir())
    download_path <- file.path(download_dest, "portalPredictions.zip")
    download_Npath <- normalizePath(download_path, mustWork = FALSE)
    if(!file.exists(download_Npath) | !control$use_existing_zip){
      msg <- paste0("Downloading files from ", releases$version[match_idx])
      messageq(msg, quiet)
      verbose <- control$verbose
      download.file(download_url, download_Npath, quiet = !verbose, 
                    mode = "wb")
      final_folder <- sub_paths(tree, "predictions")
      unzip_path <- file.path(download_dest, "unzips")
      unzip_Npath <- normalizePath(unzip_path, mustWork = FALSE)

      primary_folder <- unzip(download_Npath, list = TRUE)$Name[1]
      unzip(download_Npath, exdir = unzip_Npath)

      full_unzip_path <- file.path(unzip_Npath, list.files(unzip_Npath))
      full_unzip_Npath <- normalizePath(full_unzip_path)
      cov_path <- file.path(full_unzip_Npath, "data/covariate_forecasts.csv")
      cov_Npath <- normalizePath(cov_path)
      temp <- read.csv(cov_Npath, stringsAsFactors = FALSE)
    } else if (file.exists(download_Npath) & control$use_existing_zip) {
      messageq("Using existing downloaded files", quiet)
      final_folder <- sub_paths(tree, "predictions")
      unzip_path <- file.path(download_dest, "unzips")
      unzip_Npath <- normalizePath(unzip_path, mustWork = FALSE)

      primary_folder <- unzip(download_Npath, list = TRUE)$Name[1]
      unzip(download_Npath, exdir = unzip_Npath)

      full_unzip_path <- file.path(unzip_Npath, list.files(unzip_Npath))
      full_unzip_Npath <- normalizePath(full_unzip_path)
      cov_path <- file.path(full_unzip_Npath, "data/covariate_forecasts.csv")
      cov_Npath <- normalizePath(cov_path)
      temp <- read.csv(cov_Npath, stringsAsFactors = FALSE)
    } else {
      messageq("files not downloaded and do not exist", quiet)
    }
  }
  if (!is.null(temp) & !file.exists(path_to)){
    msg <- "Loading historical covariate forecasts into data subdirectory"
    messageq(msg, quiet)
    write.csv(temp, path_to, row.names = FALSE)    
  } else if(!is.null(temp) & control$update){
    exists <- read.csv(path_to, stringsAsFactors = FALSE) 
    if (max(temp$date_made) > max(exists$date_made)){
      messageq("Updating historical covariate forecasts", quiet)
      write.csv(temp, path_to, row.names = FALSE)
    } else{ 
      msg <- "File not moved, existing file is more current than proposed"
      messageq(msg, quiet)
    }
  }
}

#' @rdname prep_covariates
#'
#' @export
#'
prep_hist_covariates <- function(tree = dirtree(), control = list()){
  control <- do.call("covariates_control", control)
  weather_data <- prep_weather_data(tree = tree)
  ndvi_data <- ndvi("newmoon", fill = TRUE, path = main_path(tree))
  out <- right_join(weather_data, ndvi_data, by = "newmoonnumber")
  out$source <- "hist"
  if (!is.null(control$end)){
    end_step <- control$end[control$hind_step]
    out <- out[which(out$newmoonnumber <= end_step), ]
  }
  classy(out, c("covariates", "data.frame"))
}

#' @rdname prep_covariates
#'
#' @export
#'
prep_fcast_covariates <- function(hist_cov = prep_hist_covariates(),
                                  moons = prep_moons(),
                                  tree = dirtree(), quiet = FALSE, 
                                  control = list()){
  forecast_covariates(hist_cov, moons, tree, quiet, control) %>%
  append_cov_fcast_csv(tree, control) %>%
  select(-forecast_newmoon) %>%
  mutate("source" = "fcast") %>%
  classy(class = c("covariates", "data.frame"))
}

#' @rdname prep_covariates
#' 
#' @export
#'
prep_weather_data <- function(tree = dirtree()){
  cols <- c("mintemp", "maxtemp", "meantemp", "precipitation", 
            "newmoonnumber")
  weather("newmoon", fill = TRUE, path = main_path(tree)) %>% 
  ungroup() %>%
  select(cols) %>%
  remove_incompletes("newmoonnumber")
}

#' @title Enforce the specific data options for covariate forecasts based on
#'   existing data.
#'
#' @description Update the covariate data control options based on the 
#'   historical covariate data and moon data. See 
#'   \code{\link{covariates_control}}.
#'
#' @param hist_cov Historical covariate data table as a code{covariates}-class 
#'   \code{data.frame}, returned from \code{\link{prep_hist_covariates}}.
#'
#' @param moons Class-\code{moons} \code{data.frame} containing the historic 
#'   and future newmoons, as produced by \code{\link{prep_moons}}.
#'
#' @param control \code{list} of settings controlling the covariates data 
#'   creation. See \code{\link{covariates_control}}.
#'
#' @return An updated \code{list} of control options for covariates.
#'
#' @export
#'
enforce_covariates_control <- function(control = covariates_control(),
                                       hist_cov = prep_hist_covariates(), 
                                       moons = prep_moons()){

  if(length(control$cast_date) > 0 &
     length(control$hind_step) > 0 &
     length(control$lead_time) > 0){  
    prev_newmoon <- max(which(moons$newmoondate < control$cast_date))
    prev_newmoon <- moons$newmoonnumber[prev_newmoon]
    if (control$cast_type == "hindcasts"){
      prev_newmoon <- control$end[control$hind_step]    
    }
    prev_covar_newmoon <- tail(hist_cov, 1)$newmoonnumber
    first_fcast_newmoon <- prev_covar_newmoon + 1
    last_fcast_newmoon <- prev_newmoon + control$lead_time
    control$fcast_nms <- first_fcast_newmoon:last_fcast_newmoon
    control$nfcnm <- length(control$fcast_nms)
  }
  control
}

#' @rdname prep_covariates
#' 
#' @export
#'
append_cov_fcast_csv <- function(new_forecast_covariates, tree = dirtree(),
                                 control = list){
  control <- do.call("covariates_control", control)
  if (!control$append_fcast_csv){
    return(new_forecast_covariates)
  }
  if (control$cast_type == "hindcast"){
    return(new_forecast_covariates)
  }

  covar_new <- new_forecast_covariates
  covar_new$source <- control$source_name
  date_made <- today(time = TRUE)
  tz <- format(date_made, "%Z")
  covar_new$date_made <- paste0(date_made, " ", tz)

  fname <- paste0("data/", control$hist_fcast_file)
  hist_file <- file_paths(tree, fname)

  if (file.exists(hist_file)){
    covar_hist <- read.csv(hist_file, stringsAsFactors = FALSE)
    out <- rbind(covar_hist, covar_new)
  } else{
    out <- covar_new
  }
  write.csv(out, hist_file, row.names = FALSE)
  new_forecast_covariates
}

