#' @title Prepare covariate data for casting
#'
#' @description Combine the historical and cast covariate data for a model
#'  run. See \code{link{prep_hist_covariates}} and
#'  \code{\link{prep_cast_covariates}} for the historical and -casted
#'  covariate preparation details, respectively.
#'
#' @param main \code{character} value of the name of the main component of
#'  the directory tree.
#'
#' @param moons Moons \code{data.frame}. See \code{\link{prep_moons}}.
#'
#' @param lead_time \code{integer} (or integer \code{numeric}) value for the
#'  number of timesteps forward a cast will cover.
#'
#' @param min_lag \code{integer} (or integer \code{numeric}) of the minimum 
#'  covariate lag time used in any model.
#'
#' @param cast_date \code{Date} from which future is defined (the origin of
#'  the cast). In the recurring forecasting, is set to today's date
#'  using \code{\link{Sys.Date}}.
#'
#' @param end_moon \code{integer} (or integer \code{numeric}) newmoon number 
#'  of the last sample to be included. Default value is \code{NULL}, which 
#'  equates to the most recently included sample. 
#'
#' @param quiet \code{logical} indicator if progress messages should be
#'  quieted.
#'
#' @param verbose \code{logical} indicator if detailed messages should be
#'  shown.
#'
#' @param control_climate_dl \code{list} of specifications for the download, 
#'  which are sent to \code{\link{NMME_urls}} to create the specific URLs. See
#'  \code{\link{climate_dl_control}}.
#'
#' @param control_files \code{list} of names of the folders and files within
#'  the sub directories and saving strategies (save, overwrite, append, etc.).
#'  Generally shouldn't need to be edited. See \code{\link{files_control}}.
#'
#' @param arg_checks \code{logical} value of if the arguments should be
#'  checked using standard protocols via \code{\link{check_args}}. The 
#'  default (\code{arg_checks = TRUE}) ensures that all inputs are 
#'  formatted correctly and provides directed error messages if not.
#'
#' @return \code{data.frame} of historical and -casted covariates, combined
#'  and saved out to \code{filename} if indicated by \code{save}.
#'  
#' @examples
#'  \donttest{
#'   setup_dir()
#'   prep_covariates()
#'  }
#'  
#' @export
#'
prep_covariates <- function(main = ".", moons = NULL, end_moon = NULL, 
                            lead_time = 12, min_lag = 6, 
                            cast_date = Sys.Date(),
                            control_climate_dl = climate_dl_control(), 
                            control_files = files_control(),
                            quiet = TRUE, verbose = FALSE, 
                            arg_checks = TRUE){
  check_args(arg_checks = arg_checks)
  moons <- ifnull(moons, read_moons(main = main, 
                                    control_files = control_files,
                                    arg_checks = arg_checks))
  messageq("  -covariate data files", quiet)
  hist_cov <- prep_hist_covariates(main = main, end_moon = end_moon,
                                   quiet = quiet, arg_checks = arg_checks)
  cast_cov <- prep_cast_covariates(main = main, moons = moons, 
                                   hist_cov = hist_cov,
                                   end_moon = end_moon, 
                                   lead_time = lead_time, min_lag = min_lag, 
                                   cast_date = cast_date, 
                                   control_files = control_files,
                                   control_climate_dl = control_climate_dl,
                                   quiet = quiet, verbose = verbose, 
                                   arg_checks = arg_checks)
  out <- bind_rows(hist_cov, cast_cov)

  write_data(dfl = out, main = main, save = control_files$save, 
             filename = control_files$filename_cov, 
             overwrite = control_files$overwrite, 
             quiet = !verbose, arg_checks = arg_checks)
}


#' @title Prepare historical covariates data
#'
#' @description 
#'  \code{prep_hist_covariates} creates a \code{data.frame} of historical 
#'  weather and NDVI data. Automatically goes all the way back to the 
#'  beginning of the available data, as the table is automatically trimmed 
#'  later. \cr \cr
#'  \code{prep_weather_data} creates a \code{data.frame} of historical 
#'   weather data using \code{\link[portalr]{weather}}. \cr \cr
#'  NDVI data are generated by \code{\link[portalr]{ndvi}}.
#'
#' @param main \code{character} value of the name of the main component of
#'  the directory tree.
#'
#' @param end_moon \code{integer} (or integer \code{numeric}) newmoon number 
#'  of the last sample to be included. Default value is \code{NULL}, which 
#'  equates to the most recently included sample. 
#'
#' @param quiet \code{logical} indicator if progress messages should be
#'  quieted.
#'
#' @param arg_checks \code{logical} value of if the arguments should be
#'  checked using standard protocols via \code{\link{check_args}}. The 
#'  default (\code{arg_checks = TRUE}) ensures that all inputs are 
#'  formatted correctly and provides directed error messages if not. \cr
#'  However, in sandboxing, it is often desirable to be able to deviate from 
#'  strict argument expectations. Setting \code{arg_checks = FALSE} triggers
#'  many/most/all enclosed functions to not check any arguments using 
#'  \code{\link{check_args}}, and as such, \emph{caveat emptor}.
#'
#' @return 
#'  \code{prep_hist_covariates}: historical covariate data table as a 
#'   \code{data.frame}. \cr \cr
#'  \code{prep_weather_data}: \code{data.frame} of historical weather data.
#'
#' @examples
#'  \donttest{   
#'   create_dir()
#'   fill_raw()
#'   prep_hist_covariates()
#'   prep_weather_data()
#'  }
#'
#' @name prepare_historical_covariates
#'
NULL

#' @rdname prepare_historical_covariates
#'
#' @export
#'
prep_hist_covariates <- function(main = ".", end_moon = NULL, 
                                 quiet = TRUE, arg_checks = TRUE){
  check_args(arg_checks = arg_checks)
  weather_data <- prep_weather_data(main = main, arg_checks = arg_checks)
  raw_path <- raw_path(main = main, arg_checks = arg_checks)
  ndvi_data <- ndvi(level = "newmoon", fill = TRUE, path = raw_path)
  out <- right_join(weather_data, ndvi_data, by = "newmoonnumber")
  out$source <- "hist"
  colnames(out)[which(colnames(out) == "newmoonnumber")] <- "moon"
  if (!is.null(end_moon)){
    out <- out[which(out$moon <= end_moon), ]
  }
  data.frame(out)
}

#' @rdname prepare_historical_covariates
#'
#' @export
#'
prep_weather_data <- function(main = ".", arg_checks = TRUE){
  check_args(arg_checks = arg_checks)
  cols <- c("mintemp", "maxtemp", "meantemp", "precipitation", 
            "newmoonnumber")
  raw_path <- raw_path(main = main, arg_checks = arg_checks)
  weather("newmoon", TRUE, raw_path) %>% 
  ungroup() %>%
  select(cols) %>%
  remove_incompletes("newmoonnumber")
}

#' @title Summarize a daily weather table by newmoons
#'
#' @description Summarizes a daily weather table by newmoons. Taking the 
#'  max date, min of the min temperatures, max of the max temperatures,
#'  mean of the mean temperatures, and sum of the precipitation.
#'
#' @param x \code{data.frame} of daily weather, with columns named
#'  \code{"date"}, \code{"mintemp"}, \code{"maxtemp"}, \code{"meantemp"}, 
#'  \code{"precipitation"}, and \code{"moon"}.
#'
#' @return \code{data.frame} of \code{x} summarized and arranged by
#'  \code{x$moon}.
#'
#' @examples
#'  \donttest{
#'   create_dir()
#'   fill_raw()
#'   "%>%" <- dplyr::"%>%"
#'   raw_path <- raw_path()
#'   moons <- prep_moons()
#'   portalr::weather("daily", TRUE, raw_path) %>% 
#'   add_date_from_components() %>%
#'   dplyr::select(-c(year, month, day, battery_low, locally_measured))  %>%
#'   add_newmoons_from_date(moons) %>%
#'   summarize_daily_weather_by_newmoon()
#'  }
#'
#' @export
#'
summarize_daily_weather_by_moon <- function(x){
  group_by(x, moon) %>%
  summarize(date = max(date, na.rm = TRUE), 
            mintemp = min(mintemp, na.rm = TRUE), 
            maxtemp = max(maxtemp, na.rm = TRUE), 
            meantemp = mean(meantemp, na.rm = TRUE), 
            precipitation = sum(precipitation, na.rm = TRUE)) %>% 
  arrange(moon) %>% 
  select(moon, mintemp, maxtemp, meantemp, precipitation)
}



#' @title Lag covariate data
#'
#' @description Lag the covariate data together based on the new moons
#'
#' @param covariates \code{data.frame} of covariate data to be lagged. 
#'  
#' @param lag \code{integer} lag between rodent census and covariate data, in
#'  new moons.
#'  
#' @param tail \code{logical} indicator if the data lagged to the tail end 
#'  should be retained.
#'
#' @param arg_checks \code{logical} value of if the arguments should be
#'  checked using standard protocols via \code{\link{check_args}}. The 
#'  default (\code{arg_checks = TRUE}) ensures that all inputs are 
#'  formatted correctly and provides directed error messages if not. \cr
#'  However, in sandboxing, it is often desirable to be able to deviate from 
#'  strict argument expectations. Setting \code{arg_checks = FALSE} triggers
#'  many/most/all enclosed functions to not check any arguments using 
#'  \code{\link{check_args}}, and as such, \emph{caveat emptor}.
#'  
#' @return \code{data.frame} with a \code{newmoonnumber} column reflecting
#'  the lag.
#'
#' @examples
#'  \donttest{
#'   setup_dir()
#'   covariate_casts <- read_covariate_casts()
#'   covar_casts_lag <- lag_covariates(covariate_casts, lag = 2, tail = TRUE)
#'  }
#'
#' @export
#'
lag_covariates <- function(covariates, lag, tail = FALSE, 
                           arg_checks = TRUE){
  check_args(arg_checks = arg_checks)
  covariates$moon_lag <- covariates$moon + lag
  
  if(tail == FALSE){
    oldest_included_moon <- covariates$moon[1]
    most_recent_moon <- covariates$moon[nrow(covariates)]
    hist_moons <- oldest_included_moon:most_recent_moon
    hist_moons_table <- data.frame(moon = hist_moons)
    nm_match <- c("moon_lag" = "moon")
    data <- right_join(covariates, hist_moons_table, by = nm_match) 
    if (lag > 0){
      covariates <- covariates[-(1:lag), ]
    }
  }
  covariates <- select(covariates, -moon)
  cn_covariates <- colnames(covariates)
  cn_nmn_l <- which(cn_covariates == "moon_lag")
  colnames(covariates)[cn_nmn_l] <- "moon"
  covariates
}
