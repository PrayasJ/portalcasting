#' @title Prepare Covariate Data for Casting
#'
#' @description Prepare and combine the historical and cast covariate data for a model run. \cr \cr 
#'              \code{prep_hist_covariates} and \code{prep_cast_covariates} ready the historical and -casted covariates, respectively. \cr \cr
#'              \code{prepare_covariates} combines \code{prep_hist_covariates} and \code{prep_cast_covariates}.
#'
#' @param main \code{character} value of the name of the main component of the directory tree.
#'
#' @param settings \code{list} of controls for the directory, with defaults set in \code{\link{directory_settings}} that should generally not need to be altered.
#'
#' @return \code{data.frame} of historical and/or -casted covariates that is also saved out to \code{settings$files$covariates} if indicated by \code{settings$save}.
#'  
#' @details \code{prepare_historical_covariates} creates a \code{data.frame} of historical weather (\code{\link[portalr]{weather}}) and NDVI data (\code{\link[portalr]{ndvi}}). Automatically goes all the way back to the beginning of the available data, as the table is trimmed later as needed. NDVI data are generated by \code{\link[portalr]{ndvi}}. \cr \cr
#'
#' @examples
#'  \donttest{
#'   setup_dir()
#'   prep_covariates()
#'  }
#'  
#' @export
#'
prepare_covariates <- function (main     = ".", 
                                settings = directory_settings(), 
                      lead_time = 12,
                      cast_date = Sys.Date(), 
                                quiet    = TRUE, 
                                verbose  = FALSE) {



  messageq("  -covariate data files", quiet = quiet)

  historical_covariates <- prepare_historical_covariates(main = main, settings = settings, quiet = quiet, verbose = verbose)
  forecast_covariates   <- prepare_forecast_covariates(main = main, settings = settings, lead_time = lead_time, cast_date = cast_date, quiet = quiet, verbose = verbose)



  out <- combine_hist_and_cast(hist_tab = hist_cov, cast_tab = cast_cov, 
                               column = "moon")

  na_rows <- apply(is.na(out), 1, sum) > 0
  moon_in <- out$moon >= start_moon
  which_na_rows <- which(na_rows & moon_in)
  nna_rows <- length(which_na_rows)
  if(nna_rows > 0){

    cov_casts <- read_covariate_casts(main = main, 
                                      control_files = control_files)
    for(i in 1:nna_rows){
      na_moon <- out$moon[which_na_rows[i]]
      possibles <- cov_casts[cov_casts$moon == na_moon, ]

      if(NROW(possibles > 0)){
        which_possible <- which.max(as.Date(possibles$date_made))
        cols_keep <- c("mintemp", "maxtemp", "meantemp", "precipitation",
                       "ndvi")
        patch <- data.frame(moon = na_moon, 
                            possibles[which_possible, cols_keep],
                            source = "cast")
        out[which_na_rows[i], ] <- patch
      }
    }
  }

  write_data(dfl = out, main = main, save = control_files$save, 
             filename = control_files$filename_cov, 
             overwrite = control_files$overwrite, 
             quiet = !verbose)
}


#' @rdname prepare_covariates
#'
#' @export
#'
prepare_historical_covariates <- function (main     = ".", 
                                           settings = directory_settings(), 
                                           quiet    = TRUE, 
                                           verbose  = FALSE) {

  weather_data   <- weather(level = "daily", fill = TRUE, path = file.path(main, "raw"))
  ndvi_data      <- ndvi(level = "daily", path = file.path(main, "raw"))
  ndvi_data$date <- as.Date(ndvi_data$date)

  out             <- weather_data
  out$source      <- "historical"
  out$ndvi        <- NA
  out$ndvi_source <- NA

  ndvi_dates_in_weather <- na.omit(match(ndvi_data$date, weather_data$date))
  ndvi_dates_to_keep    <- ndvi_data$date %in% weather_data$date

  out$ndvi[ndvi_dates_in_weather]        <- ndvi_data$ndvi[ndvi_dates_to_keep]
  out$ndvi_source[ndvi_dates_in_weather] <- ndvi_data$source[ndvi_dates_to_keep]

  moons <- read_moons(main = main, settings = settings)

  out <- add_moons_from_date(df = out, moons = moons)

  write_data(dfl       = out, 
             main      = main, 
             save      = settings$save, 
             filename  = settings$files$historical_covariates, 
             overwrite = settings$overwrite, 
             quiet     = !verbose)

}



#' @title Summarize a daily weather table by newmoons
#'
#' @description Summarizes a daily weather table by newmoons. Taking the 
#'  max date, min of the min temperatures, max of the max temperatures,
#'  mean of the mean temperatures, and sum of the precipitation.
#'
#' @param x \code{data.frame} of daily weather, with columns named
#'  \code{"date"}, \code{"mintemp"}, \code{"maxtemp"}, \code{"meantemp"}, 
#'  \code{"precipitation"}, and \code{"moon"}.
#'
#' @return \code{data.frame} of \code{x} summarized and arranged by
#'  \code{x$moon}.
#'
#' @examples
#'  \donttest{
#'   create_dir()
#'   fill_raw()
#'   raw_path <- raw_path()
#'   moons <- prep_moons()
#'   weather <- portalr::weather("daily", TRUE, raw_path)
#'   weather <- add_date_from_components(weather)
#'   weather <- add_moons_from_date(weather, moons)
#'   summarize_daily_weather_by_moon(weather)
#'  }
#'
#' @export
#'
summarize_daily_weather_by_moon <- function(x){

  x <- x[!(is.na(x$moon)), ] 
  umoons <- unique(x$moon)
  numoons <- length(umoons)
  date <- rep(NA, numoons)
  mintemp <- rep(NA, numoons)
  maxtemp <- rep(NA, numoons)
  meantemp <- rep(NA, numoons)
  precipitation <- rep(NA, numoons)
  ndvi <- rep(NA, numoons)
  for(i in 1:numoons){
    moons_in <- x$moon == umoons[i]
    date[i] <- max(as.Date(x$date[moons_in], na.rm = TRUE))
    mm <- na.omit(x$mintemp[moons_in])
    if(length(mm) > 0){
      mintemp[i] <- min(mm, na.rm = TRUE)
    } else{
      mintemp[i] <- NA
    }

    mm <- na.omit(x$maxtemp[moons_in])
    if(length(mm) > 0){
      maxtemp[i] <- max(mm, na.rm = TRUE)
    } else{
      maxtemp[i] <- NA
    }

    mm <- na.omit(x$meantemp[moons_in])
    if(length(mm) > 0){
      meantemp[i] <- mean(mm, na.rm = TRUE)
    } else{
      meantemp[i] <- NA
    }

    pp <- na.omit(x$precipitation[moons_in])
    if(length(mm) > 0){
      precipitation[i] <- sum(pp, na.rm = TRUE)
    } else{
      precipitation[i] <- NA
    }

    nn <- na.omit(x$ndvi[moons_in])
    if(length(nn) > 0){
      ndvi[i] <- sum(nn, na.rm = TRUE)
    } else{
      ndvi[i] <- NA
    }

  }
  out <- data.frame(moon = umoons, mintemp, maxtemp, meantemp, precipitation,
                    ndvi)
  moon_order <- order(out$moon)
  out[moon_order, ]
}



#' @title Lag covariate data
#'
#' @description Lag the covariate data together based on the new moons
#'
#' @param covariates \code{data.frame} of covariate data to be lagged. 
#'  
#' @param lag \code{integer} lag between rodent census and covariate data, in
#'  new moons.
#'  
#' @param tail \code{logical} indicator if the data lagged to the tail end 
#'  should be retained.
#'
#' @return \code{data.frame} with a \code{newmoonnumber} column reflecting
#'  the lag.
#'
#' @examples
#'  \donttest{
#'   setup_dir()
#'   covariate_casts <- read_covariate_casts()
#'   covar_casts_lag <- lag_covariates(covariate_casts, lag = 2, tail = TRUE)
#'  }
#'
#' @export
#'
lag_covariates <- function(covariates, lag, tail = FALSE){

  covariates$moon_lag <- covariates$moon + lag
  
  if(tail == FALSE){
    oldest_included_moon <- covariates$moon[1]
    most_recent_moon <- covariates$moon[nrow(covariates)]
    hist_moons <- oldest_included_moon:most_recent_moon
    moon_match <- match(covariates$moon_lag, hist_moons)
    covariates$moon <- hist_moons[moon_match]
    if (lag > 0){
      covariates <- covariates[-(1:lag), ]
    }
  }
  covariates$moon <- covariates$moon_lag
  covariates$moon_lag <- NULL
  covariates
}
