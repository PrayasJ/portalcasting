% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/models_jags.R
\name{jags_ss}
\alias{jags_ss}
\title{Run a single-species JAGS model}
\usage{
jags_ss(
  main = ".",
  data_set = "all",
  control_files = files_control(),
  control_runjags = runjags_control(),
  jags_model = NULL,
  monitor = NULL,
  inits = NULL,
  lag = NA,
  quiet = FALSE,
  verbose = FALSE
)
}
\arguments{
\item{main}{\code{character} value of the name of the main component of
the directory tree.}

\item{data_set}{\code{character} value name of the rodent data set, such as 
(\code{"all"} or \code{"controls"}).}

\item{control_files}{\code{list} of names of the folders and files within
the sub directories and saving strategies (save, overwrite, append, etc.).
Generally shouldn't need to be edited. See \code{\link{files_control}}.}

\item{control_runjags}{\code{list} of arguments passed to 
\code{\link[runjags]{run.jags}} via \code{\link{runjags_control}}}

\item{jags_model}{\code{character} value of the model. See \code{Examples}.}

\item{monitor}{\code{character} vector of the names of the variables to
monitor. See \code{Examples} and \code{\link[runjags]{run.jags}}.}

\item{inits}{\code{function}, \code{character} vector, or \code{list} of
values (including random number generation components) for initializing
runs of the model. See \code{Examples} and 
\code{\link[runjags]{run.jags}}.}

\item{lag}{\code{integer} (or integer \code{numeric}) of the lag time to
use for the covariates.}

\item{quiet}{\code{logical} value indicating if the function should be 
quiet.}

\item{verbose}{\code{logical} indicator of whether or not to print out
all of the information or not (and thus just the tidy messages).}
}
\value{
\code{list} of [1] model metadata \code{list} (\code{"metadata"}), 
 [2] cast summary \code{data.frame} (\code{"cast_tab"}),
 [3] \code{list} of model fit objects (\code{"model_fits"}), and 
 [4] \code{list} of model cast objects (\code{"model_casts"}).
}
\description{
Provides an API to \code{\link[runjags]{run.jags}} for
 single-species portalcasting models that requires the user only provide
 the JAGS model, initializer, monitor, and control list.
}
\details{
The data structure constructed internally, which is available to
 the \code{jags_model} and \code{inits} components, contains the following
 elements: \code{count}, \code{moon}, and \code{ntraps} (all three 
 include the forecast horizon as well, with \code{NA} for \code{count},
 \code{moon} extended as expected, and \code{ntraps} using the max number
 of traps); \code{N} (the length of the \code{count} time series); 
 \code{past_count}, \code{past_moon}, and \code{past_ntraps}, which 
 provide all of the historic data that preceded \code{start_moon}
 (only including samples that are present; all \code{NA} counts are 
 removed as are associated trap count sand moons); \code{past_N} (the 
 length of the \code{past_count} time series); and if desired, 
 \code{covariates} (table of all covariates for the span of \code{moon}).
 and \code{past_covariates} (table of all covariates for the span of 
 \code{past_moon}).
}
\examples{
 \donttest{
  setup_dir()

  monitor <- c("mu", "tau")
  inits <- function(data = NULL){
    rngs <- c("base::Wichmann-Hill", "base::Marsaglia-Multicarry",
             "base::Super-Duper", "base::Mersenne-Twister")
    past_N <- data$past_N 
    past_count <- data$past_count 
    past_moon <- data$past_moon

    log_past_count <- log(past_count + 0.1)
    mean_log_past_count <- mean(log_past_count)
    sd_log_past_count <- max(c(sd(log_past_count) * sqrt(2), 0.01))
    diff_log_past_count <- rep(NA, past_N - 1)
    for(i in 1:(past_N - 1)){
      diff_count <- log_past_count[i + 1] - log_past_count[i]
      diff_time <- past_moon[i + 1] - past_moon[i] 
      diff_log_past_count[i] <- diff_count / diff_time
    }
    sd_diff_log_past_count <- max(c(sd(diff_log_past_count) * sqrt(2), 
                                  0.01))
    var_diff_log_past_count <- sd_diff_log_past_count^2
    precision_diff_log_past_count <- 1/(var_diff_log_past_count)
    rate <- 0.1
    shape <- precision_diff_log_past_count * rate

    function(chain = chain){
      list(.RNG.name = sample(rngs, 1),
           .RNG.seed = sample(1:1e+06, 1),
            mu = rnorm(1, mean_log_past_count, sd_log_past_count), 
            tau = rgamma(1, shape = shape, rate = rate))
    }
  }
  jags_model <- "model {  
    # priors
    log_past_count <- log(past_count + 0.1)
    mean_log_past_count <- mean(log_past_count)
    sd_log_past_count <- max(c(sd(log_past_count) * sqrt(2), 0.01))
    var_log_past_count <- sd_log_past_count^2
    precision_log_past_count <- 1/(var_log_past_count)

    diff_count[1] <- log_past_count[2] - log_past_count[1]
    diff_time[1] <- past_moon[2] - past_moon[1] 
    diff_log_past_count[1] <- diff_count[1] / diff_time[1]
    for(i in 2:(past_N - 1)){
      diff_count[i] <- log_past_count[i + 1] - log_past_count[i]
      diff_time[i] <- past_moon[i + 1] - past_moon[i] 
      diff_log_past_count[i] <- diff_count[i] / diff_time[i]
    }    
    sd_diff_log_past_count <- max(c(sd(diff_log_past_count) * sqrt(2), 
                                  0.01))
    var_diff_log_past_count <- sd_diff_log_past_count^2
    precision_diff_log_past_count <- 1/(var_diff_log_past_count)
    rate <- 0.1
    shape <- precision_diff_log_past_count * rate

    mu ~ dnorm(mean_log_past_count, precision_log_past_count); 
    tau ~ dgamma(shape, rate); 
   
    # initial state
    X[1] <- mu;
    pred_count[1] <- max(c(exp(X[1]) - 0.1, 0.00001));
    count[1] ~ dpois(max(c(exp(X[1]) - 0.1, 0.00001))) T(0,ntraps[1]);
    # through time
    for(i in 2:N) {
      # Process model
      predX[i] <- X[i-1];
      checkX[i] ~ dnorm(predX[i], tau); 
      X[i] <- min(c(checkX[i], log(ntraps[i] + 1))); 
      pred_count[i] <- max(c(exp(X[i]) - 0.1, 0.00001));
   
      # observation model
      count[i] ~ dpois(max(c(exp(X[i]) - 0.1, 0.00001))) T(0, ntraps[i]); 
    }
  }"

  jags_ss(jags_model = jags_model, monitor = monitor, inits = inits)
 }


}
\references{
Denwood, M. J. 2016. runjags: an R package providing interface
 utilities, model templates, parallel computing methods and additional
 distributions for MCMC models in JAGS. Journal of Statistical
 Software, 71:9. 
 \href{https://www.jstatsoft.org/article/view/v071i09}{URL}. 
 
 Plummer, M. 2003. JAGS: A program for analysis of Bayesian graphical 
 models using Gibbs Sampling. Proceedings of the 3rd International 
 \href{https://bit.ly/33aQ37Y}{URL}.
}
